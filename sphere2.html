<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            overflow: hidden;
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100vh;
            background-image: linear-gradient(to right bottom, #030303, #222121, #3c3a3a, #585655, #747471);
        }
        .viz {
            position: fixed;
            top: 20%;
            left: 40%;
            width: 60%;
            height: 75%;
        }
        canvas {
            display: block;
        }
        *:focus {
            outline: none;
        }
        .dg.main .close-button.close-bottom,
        .dg.a {
            width: 500px !important;
        }
    </style>
</head>

<body>

<div class="viz"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.0/gsap.min.js"></script>

<script type="module">

    import * as THREE from './js/threejs/three.module.js';
    import { OrbitControls } from './js/threejs/OrbitControls.js';

    const container = document.querySelector('.viz');

    const pinkCol = new THREE.Color('#E50142');
    const blackCol = new THREE.Color('#222222');

    let settings = {
        mainGroupRotation: 10,
        backShapeRotation: 12,
        backShapeScaling: 4,
        pointsColor: 2,
        pointsScale: 2,
        pointsMaxSize: 0.6,
        morphingPowerInner: 0.8,
        morphingPowerOuter: 0.4
    };

    let viz, controls, animations;

    document.addEventListener('DOMContentLoaded', () => {
        viz = new Viz();
        controls = new Controls();
        animations = new Animations();

        window.addEventListener('resize', () => {
            viz.updateSize(container.clientWidth, container.clientHeight);
        }, false);

        document.addEventListener('mousemove', function(e) {
            const mX = e.pageX;
            const mY = e.pageY;
            let distance = Math.floor(Math.sqrt(Math.pow(mX - (container.offsetLeft+(container.offsetWidth/2)), 2) + Math.pow(mY - (container.offsetTop + (container.offsetHeight/2)), 2)));
            distance = distance / Math.min(window.innerWidth, window.innerHeight);
            viz.mainWireframe.morphTargetInfluences[1] = -(settings.morphingPowerInner - distance) * settings.morphingPowerOuter;
            const scale = 1 - 0.1 * distance;
            viz.group.scale.set(scale, scale, scale);
        }, false);

        viz.updateSize(container.clientWidth, container.clientHeight);
        viz.loop();
    });



    class Controls {
        constructor() {
            this.gui = new dat.gui.GUI;
            this.gui.add(settings, 'morphingPowerInner', 0.1, 1, 0.1).name('morphing inner influence');
            this.gui.add(settings, 'morphingPowerOuter', 0.1, 1, 0.1).name('morphing power');
            this.gui.add(settings, 'mainGroupRotation', 1, 20, 1).name('main group rotation duration').onChange((v) => {
                animations = new Animations();
            });
            this.gui.add(settings, 'backShapeRotation', 1, 20, 1).name('back shape rotation duration').onChange((v) => {
                animations = new Animations();
            });
            this.gui.add(settings, 'backShapeScaling', 1, 10, 0.2).name('back shape scaling duration').onChange((v) => {
                animations = new Animations();
            });
            this.gui.add(settings, 'pointsColor', 0.1, 4, 0.2).name('points color animation duration').onChange((v) => {
                animations = new Animations();
            });
            this.gui.add(settings, 'pointsScale', 0.1, 4, 0.2).name('points scale animation duration').onChange((v) => {
                animations = new Animations();
            });
            this.gui.add(settings, 'pointsMaxSize', 0.4, 1.5, 0.05).name('points scale max size').onChange((v) => {
                animations = new Animations();
            });
        }
    }

    class Animations {
        constructor() {
            gsap.globalTimeline.clear();

            gsap.fromTo(viz.group.rotation, {
                x: 0,
                y: 0,
            }, {
                duration: settings.mainGroupRotation,
                x: Math.PI * 2,
                y: Math.PI * 2,
                ease: 'none',
                repeat: -1
            });
            gsap.fromTo(viz.outerWireframe.rotation, {
                x: 0,
                y: 0,
            }, {
                duration: settings.backShapeRotation,
                x: Math.PI * 2,
                y: Math.PI * 2,
                ease: 'none',
                repeat: -1
            });
            gsap.fromTo(viz.outerWireframe.scale, {
                x: 0.85,
                y: 0.85,
                z: 0.85,
            }, {
                duration: settings.backShapeScaling,
                x: 1.2,
                y: 1.2,
                z: 1.2,
                ease: 'power3.inOut',
                yoyo: true,
                repeat: -1
            });

            viz.spheres.forEach((s, sIdx) => {
                const fstCol = sIdx % 2 ? blackCol : pinkCol;
                const scdCol = !(sIdx % 2) ? blackCol : pinkCol;
                gsap.fromTo(s.material.color, {
                    r: fstCol.r,
                    g: fstCol.g,
                    b: fstCol.b,
                }, {
                    duration: settings.pointsColor,
                    r: scdCol.r,
                    g: scdCol.g,
                    b: scdCol.b,
                    repeat: -1,
                    yoyo: true
                }).progress(Math.random() * settings.pointsColor);
                gsap.fromTo(s.scale, {
                    x: 0.35,
                    y: 0.35,
                    z: 0.35,
                }, {
                    duration: settings.pointsScale,
                    x: settings.pointsMaxSize,
                    y: settings.pointsMaxSize,
                    z: settings.pointsMaxSize,
                    repeat: -1,
                    ease: 'power3.inOut',
                    yoyo: true
                }).progress(Math.random() * settings.pointsScale * 2);
            });
        }
    }


    class Viz {

        constructor() {
            this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setClearColor(0x000000, 0);
            this.container = document.getElementsByClassName('viz')[0];
            this.container.appendChild(this.renderer.domElement);

            this.scene = new THREE.Scene();
            this.scene.fog = new THREE.Fog(0x777777, 25, 50);

            this.camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 1, 1000);
            this.camera.position.z = 35;

            this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
            this.orbitControls.enableDamping = true;
            this.orbitControls.minDistance = this.orbitControls.maxDistance = 35;

            this.createGlobe();
            this.render();
        }

        createGlobe() {

            this.group = new THREE.Group();

            const geometry = new THREE.IcosahedronBufferGeometry(10, 1);
            const positionsIcosahedron = geometry.attributes.position.array;
            this.spheres  = [];
            let mainVertices = [];
            let otherVertices = [];

            let indexOfCoordinate = (array, coordinate) => {
                for (let i = 0; i < array.length; i++) {
                    if (array[i].coord[0] === coordinate[0] && array[i].coord[1] === coordinate[1] && array[i].coord[2] === coordinate[2]) {
                        return i;
                    }
                }
                return -1;
            };

            const verticesToMorph = [0, 5, 6, 13, 16, 20, 23, 26, 30, 33];
            let morphIdx = 0;
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const coord = [positionsIcosahedron[i * 3], positionsIcosahedron[i * 3 + 1], positionsIcosahedron[i * 3 + 2]];
                const coordIdx = indexOfCoordinate(mainVertices, coord);
                if (coordIdx === -1) {
                    mainVertices.push({
                        idx: i,
                        coord: coord
                    });
                    if (verticesToMorph.indexOf(morphIdx) === -1) {
                        const geometry = new THREE.SphereGeometry(.5, 16, 16);
                        const material = new THREE.MeshLambertMaterial({});
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.x = coord[0];
                        sphere.position.y = coord[1];
                        sphere.position.z = coord[2];
                        this.spheres.push(sphere);
                        this.group.add(sphere);
                    }
                    morphIdx ++;
                } else {
                    otherVertices.push({
                        idx: i,
                        coord: coord
                    });
                }
            }
            let verticesOrdered = [];

            const equalArrays = (a, b) => JSON.stringify(a) === JSON.stringify(b);
            for (let i = 0; i < mainVertices.length; i++) {
                let toMoveTogether = [];
                toMoveTogether.push(mainVertices[i].idx);
                for (let j = 0; j < otherVertices.length; j++) {
                    if (equalArrays(mainVertices[i].coord, otherVertices[j].coord)) {
                        toMoveTogether.push(otherVertices[j].idx);
                    }
                }
                verticesOrdered.push(toMoveTogether);
            }

            const hemisphereLight = new THREE.HemisphereLight(0x999999, 0xFFFFFF, 1.);
            this.scene.add(hemisphereLight);

            const outerMaterial = new THREE.MeshLambertMaterial({
                fog: true,
                color: 0x444444,
                wireframe: true
            });
            this.outerWireframe = new THREE.Mesh(geometry, outerMaterial);

            const pointsMaterial = new THREE.PointsMaterial({
                color: blackCol,
                size: 12,
                sizeAttenuation: false,
                map: new THREE.TextureLoader().load( './img/disc.png' ),
                alphaTest: 0.5,
                morphTargets: true
            });
            this.points = new THREE.Points(geometry, pointsMaterial);

            let positionsChangedIcosahedron = [];
            const vec = new THREE.Vector3();
            const positionAttribute = geometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i ++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);
                vec.set(x, y, z);
                const direction = vec.clone().normalize();
                verticesToMorph.forEach((morphIdx) => {
                    if (verticesOrdered[morphIdx].indexOf(i) !== -1) {
                        vec.addScaledVector(direction, -5);
                    }
                });
                vec.toArray(positionsChangedIcosahedron, positionsChangedIcosahedron.length);
            }
            geometry.morphAttributes.position = [
                geometry.attributes.position,
                new THREE.Float32BufferAttribute(positionsChangedIcosahedron, 3),
            ];

            this.mainMaterial = new THREE.MeshLambertMaterial({
                fog: true,
                color: 0x111111,
                wireframe: true,
                morphTargets: true,
            });
            this.mainWireframe = new THREE.Mesh(geometry, this.mainMaterial);

            this.points.morphTargetInfluences = this.mainWireframe.morphTargetInfluences;

            this.scene.add(this.outerWireframe);
            this.group.scale.set(0.85, 0.85, 0.85);
            this.group.add(this.mainWireframe);
            this.group.add(this.points);
            this.scene.add(this.group);
        }

        render() {
            this.renderer.render(this.scene, this.camera);
        }

        loop() {
            this.orbitControls.update();
            this.render();
            requestAnimationFrame(this.loop.bind(this));
        }

        updateSize(w, h) {
            this.camera.aspect = container.clientWidth / container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(w, h);
        }
    }
</script>

</body>

</html>
