<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="author" content="Ksenia Kondrashova">
    <style>
        html, body {
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script type="x-shader/x-fragment" id="fragmentShader">
    uniform float u_ratio;
    uniform vec2 u_point;
    uniform sampler2D u_texture;
    varying vec2 vUv;

    float circle (vec2 dist, float radius) {
        return 1. - smoothstep(radius * .0, radius, dot(dist, dist) * 4.);
    }

    void main() {
        vec3 base = texture2D(u_texture, vUv).xyz;
        vec2 cursor = vUv - u_point.xy;
        cursor.x *= u_ratio;

        float circle = circle(cursor, .001);
        vec3 circle_color = vec3(.3, .9, .5);
        vec3 color = base * (1. - circle) + circle * circle_color;

        gl_FragColor = vec4(color, 1.);
    }

</script>

<script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.);
    }
</script>

<script type="module">

    import * as THREE from "https://unpkg.com/three@0.146.0/build/three.module.js";

    const canvasEl = document.querySelector('#canvas');

    const pointer = {
        x: -1,
        y: -1,
    };
    let renderer, sceneShader, sceneBasic, renderTargets, camera;
    let basicMaterial, shaderMaterial;

    renderer = new THREE.WebGLRenderer({
        canvas: canvasEl,
        alpha: true,
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    sceneShader = new THREE.Scene();
    sceneBasic = new THREE.Scene();
    camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);

    renderTargets = [
        new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight),
        new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight)
    ];

    createPlane();
    updateSize();
    window.addEventListener('resize', updateSize);

    render();

    window.addEventListener("mousemove", (e) => {
        pointer.x = e.pageX / window.innerWidth;
        pointer.y = e.pageY / window.innerHeight;
    });
    window.addEventListener("touchmove", (e) => {
        pointer.x = e.targetTouches[0].pageX / window.innerWidth;
        pointer.y = e.targetTouches[0].pageY / window.innerHeight;
    });

    function createPlane() {
        shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                u_point: {type: "v2", value: new THREE.Vector2(pointer.x, pointer.y)},
                u_ratio: {type: "f", value: window.innerWidth / window.innerHeight},
                u_texture: {type: "t", value: null}
            },
            vertexShader: document.getElementById("vertexShader").textContent,
            fragmentShader: document.getElementById("fragmentShader").textContent
        });
        basicMaterial = new THREE.MeshBasicMaterial();
        const planeGeometry = new THREE.PlaneGeometry(2, 2);
        const planeBasic = new THREE.Mesh(planeGeometry, basicMaterial);
        const planeShader = new THREE.Mesh(planeGeometry, shaderMaterial);
        sceneBasic.add(planeBasic);
        sceneShader.add(planeShader);
    }

    function render() {
        shaderMaterial.uniforms.u_point.value = new THREE.Vector2(pointer.x, 1 - pointer.y);
        shaderMaterial.uniforms.u_texture.value = renderTargets[0].texture;
        shaderMaterial.uniforms.u_ratio.value = window.innerWidth / window.innerHeight;

        renderer.setRenderTarget(renderTargets[1]);
        renderer.render(sceneShader, camera);
        basicMaterial.map = renderTargets[1].texture;
        renderer.setRenderTarget(null);
        renderer.render(sceneBasic, camera);

        let tmp = renderTargets[0];
        renderTargets[0] = renderTargets[1];
        renderTargets[1] = tmp;

        requestAnimationFrame(render);
    }

    function updateSize() {
        shaderMaterial.uniforms.u_ratio.value = window.innerWidth / window.innerHeight;
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

</script>

</body>
</html>
