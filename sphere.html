<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            overflow: hidden;
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100vh;
            background-image: linear-gradient(to right bottom, #030303, #222121, #3c3a3a, #585655, #747471);
        }
        .surface {
            position: fixed;
            top: 20%;
            left: 40%;
            width: 60%;
            height: 75%;
        }
        canvas {
            display: block;
        }
        *:focus {
            outline: none;
        }
    </style>
</head>

<body>

<div class="surface"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.0/gsap.min.js"></script>
<script type="module">
    import * as THREE from './js/threejs/three.module.js';
    import { OrbitControls } from './js/threejs/OrbitControls.js';

    const container = document.querySelector('.surface');

    const pinkCol = new THREE.Color('#E50142');
    const blackCol = new THREE.Color('#222222');


    document.addEventListener('DOMContentLoaded', () => {
        let surface = new Surface();
        surface.updateSize(container.clientWidth, container.clientHeight);
        window.addEventListener('resize', () => {
            surface.updateSize(container.clientWidth, container.clientHeight);
        }, false);
        surface.loop();

        gsap.to(surface.group.rotation, {
            duration: 10,
            x: Math.PI * 2,
            y: Math.PI * 2,
            ease: 'none',
            repeat: -1
        });
        gsap.to(surface.outerWireframe.rotation, {
            duration: 12,
            x: Math.PI * 2,
            y: Math.PI * 2,
            ease: 'none',
            repeat: -1
        });
        gsap.to(surface.mainWireframe.morphTargetInfluences, {
            duration: 5,
            [1]: 1,
            ease: 'power4.inOut',
            repeat: -1,
            yoyo: true
        });
        surface.spheres.forEach((s, sIdx) => {
            const fstCol = sIdx % 2 ? blackCol : pinkCol;
            const scdCol = !(sIdx % 2) ? blackCol : pinkCol;
            gsap.fromTo(s.material.color, {
                r: fstCol.r,
                g: fstCol.g,
                b: fstCol.b,
            }, {
                duration: 3,
                r: scdCol.r,
                g: scdCol.g,
                b: scdCol.b,
                repeat: -1,
                yoyo: true
            }).progress(Math.random() * 2);
            gsap.fromTo(s.scale, {
                x: 0.4,
                y: 0.4,
                z: 0.4,
            }, {
                duration: 4,
                x: 0.6,
                y: 0.6,
                z: 0.6,
                repeat: -1,
                ease: 'power3.inOut',
                yoyo: true
            }).progress(Math.random() * 4);
        });
        gsap.fromTo(surface.outerWireframe.scale, {
            x: 0.85,
            y: 0.85,
            z: 0.85,
        }, {
            duration: 4,
            x: 1.2,
            y: 1.2,
            z: 1.2,
            ease: 'power3.inOut',
            yoyo: true,
            repeat: -1
        });
    });


    class Surface {

        constructor() {
            this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setClearColor(0x000000, 0);
            this.container = document.getElementsByClassName('surface')[0];
            this.container.appendChild(this.renderer.domElement);

            this.scene = new THREE.Scene();
            this.scene.fog = new THREE.Fog(0x777777, 25, 50);

            this.camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 1, 1000);
            this.camera.position.z = 35;

            const controls = new OrbitControls(this.camera, this.renderer.domElement);
            controls.minDistance = controls.maxDistance = 35;

            this.createSphere();
            this.render();
        }

        createSphere() {

            this.group = new THREE.Group();

            const geometry = new THREE.IcosahedronBufferGeometry(10, 1);
            const positionsIcosahedron = geometry.attributes.position.array;
            this.spheres  = [];
            let mainVertices = [];
            let otherVertices = [];

            let indexOfCoordinate = (array, coordinate) => {
                for (let i = 0; i < array.length; i++) {
                    if (array[i].coord[0] === coordinate[0] && array[i].coord[1] === coordinate[1] && array[i].coord[2] === coordinate[2]) {
                        return i;
                    }
                }
                return -1;
            };

            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const coord = [positionsIcosahedron[i * 3], positionsIcosahedron[i * 3 + 1], positionsIcosahedron[i * 3 + 2]];
                const coordIdx = indexOfCoordinate(mainVertices, coord);
                if (coordIdx === -1) {
                    mainVertices.push({
                        idx: i,
                        coord: coord
                    });
                    const geometry = new THREE.SphereGeometry(.5, 16, 16);
                    const material = new THREE.MeshLambertMaterial({ });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.x = coord[0];
                    sphere.position.y = coord[1];
                    sphere.position.z = coord[2];
                    this.spheres.push(sphere);
                    this.group.add(sphere);
                } else {
                    otherVertices.push({
                        idx: i,
                        coord: coord
                    });
                }
            }
            let verticesOrdered = [];

            const equalArrays = (a, b) => JSON.stringify(a) === JSON.stringify(b);
            for (let i = 0; i < mainVertices.length; i++) {
                let toMoveTogether = [];
                toMoveTogether.push(mainVertices[i].idx);
                for (let j = 0; j < otherVertices.length; j++) {
                    if (equalArrays(mainVertices[i].coord, otherVertices[j].coord)) {
                        toMoveTogether.push(otherVertices[j].idx);
                    }
                }
                verticesOrdered.push(toMoveTogether);
            }

            const hemisphereLight = new THREE.HemisphereLight(0x999999, 0xFFFFFF, 1.);
            this.scene.add(hemisphereLight);

            this.mainMaterial = new THREE.MeshLambertMaterial({
                fog: true,
                color: 0x111111,
                wireframe: true,
                morphTargets: true,
            });

            this.outerMaterial = new THREE.MeshLambertMaterial({
                fog: true,
                color: 0x444444,
                wireframe: true
            });
            this.outerWireframe = new THREE.Mesh(geometry, this.outerMaterial);


            const pointsMaterial = new THREE.PointsMaterial( {
                color: blackCol,
                size: 15,
                sizeAttenuation: false,
                map: new THREE.TextureLoader().load( './img/disc.png' ),
                alphaTest: 0.5,
                morphTargets: true
            } );

            this.points = new THREE.Points(geometry, pointsMaterial);


            let positionsChangedIcosahedron = [];
            const verticesToMorph = [0, 5, 6, 13, 16, 20, 23, 26, 30, 33];
            const vec = new THREE.Vector3();
            const positionAttribute = geometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i ++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);
                vec.set(x, y, z);
                const direction = vec.clone().normalize();
                verticesToMorph.forEach((morphIdx) => {
                    if (verticesOrdered[morphIdx].indexOf(i) !== -1) {
                        vec.addScaledVector(direction, -4);
                    }
                });
                vec.toArray(positionsChangedIcosahedron, positionsChangedIcosahedron.length);
            }
            geometry.morphAttributes.position = [
                geometry.attributes.position,
                new THREE.Float32BufferAttribute(positionsChangedIcosahedron, 3),
            ];
            this.mainWireframe = new THREE.Mesh(geometry, this.mainMaterial);

            this.points.morphTargetInfluences = this.mainWireframe.morphTargetInfluences;

            this.group.scale.set(0.85, 0.85, 0.85);
            this.group.add(this.mainWireframe);
            this.group.add(this.points);
            this.scene.add(this.group);
            this.scene.add(this.outerWireframe);
        }

        render() {
            this.renderer.render(this.scene, this.camera);
        }

        loop() {
            this.render();
            requestAnimationFrame(this.loop.bind(this));
        }

        updateSize(w, h) {
            this.camera.aspect = container.clientWidth / container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(w, h);
        }
    }
</script>

</body>

</html>
