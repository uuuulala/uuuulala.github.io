<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="author" content="Ksenia Kondrashova">
    <style>
        html, body {
            padding: 0;
            margin: 0;
        }
        body {
            width: 100%;
            height: 100vh;
            background: linear-gradient(to bottom, #a1e4ff, #737470);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .animation-container {
            width: 900px;
        }
        .animation-container canvas {
            width: 100%;
            /*border: 1px solid brown;*/
        }
    </style>
</head>

<body>

<div class="animation-container">
    <canvas id="animation"></canvas>
</div>


<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18"></script>
<!--<script src="gsap.min.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>

<script>


    const containerEl = document.querySelector(".animation-container");
    const canvasEl = containerEl.querySelector("#animation");
    const ctx = canvasEl.getContext('2d');

    const pics = {
        "logo": "logo.png",
        "handshake": "handshake.png",
        "chart": "chart.png"
    }
    
    const resolution = 2;
    const params = {
        density: 2.5 * resolution,
        radius: 5 * resolution,
        mouseMagnet: 5000 * resolution,
        mouseThreshold: .5,
        padding: [.1, .1],
        floatingSpeed: 10,
        floatingDist: 15,
        sizeRandomness: 1,

        pic: pics.logo
    }

    let mouse = {
        x: -100000, y: -10000
    };

    let data = [];
    let size = [];

    const controls = {
        density: params.density / resolution,
        radius: params.radius / resolution,
        mouseMagnet: params.mouseMagnet / resolution,
    }

    const imgEl = new Image();
    imgEl.src = params.pic;


    imgEl.onload = function () {
        imageToParticles(imgEl);
        gsap.ticker.add(t => {
            drawDots(t);
        });
        addListeners();
        createControls();
    }

    window.addEventListener("resize", () => {
        data = [];
        imageToParticles(imgEl);
    });


    function imageToParticles(img) {
        const imageRatio = img.width / img.height;
        const pixelWidth = containerEl.clientWidth;

        size = [pixelWidth, pixelWidth / imageRatio];
        size = size.map(v => resolution * v);

        canvasEl.width = size[0];
        canvasEl.height = size[1];
        canvasEl.width += 2 * params.padding[0] * size[0];
        canvasEl.height += 2 * params.padding[1] * size[1];

        sampleCoordinates();
    }

    function addListeners() {
        containerEl.onmousemove = function (e) {

            mouse.x = e.offsetX;
            mouse.y = e.offsetY;
            mouse.x *= (1 + 2 * params.padding[0]);
            mouse.y *= (1 + 2 * params.padding[1]);
            mouse.x *= resolution;
            mouse.y *= resolution;
        }
        containerEl.ontouchmove = function (e) {
            const rect = e.target.getBoundingClientRect();
            mouse.x = e.targetTouches[0].pageX - rect.left;
            mouse.y = e.targetTouches[0].pageY - rect.top;
            mouse.x *= (1 + 2 * params.padding[0]);
            mouse.y *= (1 + 2 * params.padding[1]);
            mouse.x *= resolution;
            mouse.y *= resolution;
        }

        let touchMagnet = params.mouseMagnet;
        containerEl.ontouchstart = function () {
            gsap.to(params, {
                mouseMagnet: touchMagnet,
            })
        }
        containerEl.ontouchend = function () {
            touchMagnet = params.mouseMagnet
            gsap.to(params, {
                mouseMagnet: 0,
            })
        }
    }





    function sampleCoordinates() {

        ctx.drawImage(imgEl, params.padding[0] * size[0], params.padding[1] * size[1], size[0], size[1]);

        const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);

        const step = 4 * params.density;
        const start = Math.ceil(params.radius);
        const endHeight = Math.floor(canvasEl.height - params.radius);
        const endWidth = Math.floor(canvasEl.width - params.radius);
        for (let i = start; i < endHeight; i += step) {
            for (let j = start; j < endWidth; j += step) {
                const whiteLimit = 120;
                const isBack = (
                    imageData.data[(j + i * canvasEl.width) * 4] > whiteLimit &&
                    imageData.data[(j + i * canvasEl.width) * 4 + 1] > whiteLimit &&
                    imageData.data[(j + i * canvasEl.width) * 4 + 2] > whiteLimit
                )
                const isTransparent = (
                    imageData.data[(j + i * canvasEl.width) * 4 + 3] < .5
                )
                if (!isBack && !isTransparent) {
                    data.push({
                        xy: [j, i],
                        base: [ j, i ],
                        target: [ j, i ],
                        color: {
                            r: imageData.data[(j + i * canvasEl.width) * 4],
                            g: imageData.data[(j + i * canvasEl.width) * 4 + 1],
                            b: imageData.data[(j + i * canvasEl.width) * 4 + 2],
                        },
                        r: params.radius * (1 + params.sizeRandomness * (Math.random() - .5)),
                        speed: .5 + .5 * Math.random(),
                        floatingTimeStart: Math.random() * 2 * Math.PI,
                        floatingDist: [ params.floatingDist * (.2 + Math.random()), params.floatingDist * (.2 + Math.random()) ]
                    });
                }
            }
        }
    }


    function drawDots(t) {
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        for (let i = 0; i < data.length; i++) {
            const d = data[i];
            ctx.fillStyle = "rgb(" + d.color.r + ", " + d.color.g + ", " + d.color.b + ")";

            let dX = mouse.x - d.target[0];
            let dY = mouse.y - d.target[1];

            let sqDist = (dX * dX) + (dY * dY);

            const floatingOffset = [
                Math.sin(params.floatingSpeed * d.speed * t + d.floatingTimeStart) * d.floatingDist[0],
                Math.cos(params.floatingSpeed * d.speed * t + d.floatingTimeStart) * d.floatingDist[1]
            ]

            const mouseOffset = [
                params.mouseMagnet * dX / sqDist,
                params.mouseMagnet * dY / sqDist,
            ]

            d.target[0] = d.base[0] + floatingOffset[0] - mouseOffset[0];
            d.target[1] = d.base[1] + floatingOffset[1] - mouseOffset[1];

            d.xy[0] += (d.target[0] - d.xy[0]) * params.mouseThreshold;
            d.xy[1] += (d.target[1] - d.xy[1]) * params.mouseThreshold;


            ctx.beginPath();
            ctx.arc(
                d.xy[0],
                d.xy[1],
                d.r,
                0,
                Math.PI * 2,
                true
            );
            ctx.closePath();
            ctx.fill();
        }

    }

    function createControls() {

        const GUI = new lil.GUI();

        GUI.add(controls, "density", .5, 10).step(.5).onChange(v => {
            data = [];
            params.density = v * resolution;
            imageToParticles(imgEl);
        }).name("density");

        GUI.add(controls, "radius", .5, 10).step(.5).onChange(v => {
            data = [];
            params.radius = v * resolution;
            imageToParticles(imgEl);
        }).name("radius");

        GUI.add(controls, "mouseMagnet", 100, 10000).step(.5).onChange(v => {
            params.mouseMagnet = v * resolution;
        }).name("mouse radius");

        GUI.add(params, "mouseThreshold", .1, 1).step(.01).name("mouse response");
        GUI.add(params, "floatingSpeed", 1, 30).step(1).name("floating speed");


        GUI.add(params, "floatingDist", 0, 30).step(.5).onChange(v => {
            data = [];
            imageToParticles(imgEl);
        }).name("floating distance");

        GUI.add(params, "sizeRandomness", 0, 1).step(.01).onChange(v => {
            data = [];
            imageToParticles(imgEl);
        }).name("size variation");

        GUI.add(params, "pic", Object.keys(pics)).onChange(v => {
            imgEl.src = pics[v];
            data = [];
            imgEl.onload = function () {
                imageToParticles(imgEl);
            }

        });


    }


</script>

</body>
</html>